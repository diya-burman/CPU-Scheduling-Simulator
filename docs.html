<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="./docs.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <title>CPU Scheduler</title>

    <style>
        /* Basic styling */
        .blog-text {
            margin: 20px;
        }

        .blog-title {
            font-size: 20px;
            color: rgb(0, 0, 255);
        }

        /* Card styling */
        .card {
            display: none;
            /* Initially hidden */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 500px;
            border: 1px solid #ccc;
            z-index: 1000;
            overflow-y: auto;
            max-height: 70vh;
            background-color: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 20px;
            transition: transform 0.3 ease-in-out;
        }

        .card:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            margin-top: 0;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .card p {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        /* Overlay styling */
        .overlay {
            display: none;
            /* Initially hidden */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Close button styling */
        .close-btn {
            background: none;
            color: #333;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            float: right;
            font-size: 20px;
            position: absolute;
            top: 10px;
            right: 10px;
            font-weight: bold;
            transition: all 1s ease-in-out;
            border: 1px solid #000000;
            /* Add a border */
            padding: 1px 11px;
            /* Adjust padding for the border */
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <section class="sub-header">
        <nav>
            <a href="index.html" id="op">CPU Scheduler</a>
            <div class="nav-links" id="navLinks">
                <i class="fas fa-window-close" onclick="hideMenu()"></i>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="docs.html">Document</a></li>
                    <li><a href="./backend/ganttcharts.html">Simulator</a></li>
                    <li><a href="feedback.html">Feedback</a></li>
                    <li><a href="about.html">About</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </div>
            <i class="fas fa-bars" onclick="showMenu()"></i>
        </nav>

        <h1 id="docc">Documentation</h1>

    </section>
    <section id="blog">
        <div class="CPU-heading">
        </div>

        <div class="blog-container" data-aos="zoom-in-up">
            <!-- FCFS -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('fcfs')">First Come First Serve
                        (FCFS)</a>
                    <p>FCFS schedules processes strictly in the order of their arrival in a queue. When a process
                        arrives...</p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('fcfs')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>

                <div class="card" id="fcfs-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>First Come First Serve (FCFS)</h2>
                    <p><strong>Mechanism:</strong> FCFS schedules processes strictly in the order of their arrival in a
                        queue. When a process arrives, it's added to the end of the queue. The CPU processes each task
                        in turn, moving from the front to the back of the queue.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Non-preemptive:</strong> Once a process starts executing, it will run until
                            completion, even if another process arrives with higher priority.</li>
                        <li><strong>Fairness:</strong> All processes get to execute in the order they arrive, which
                            prevents newer tasks from taking CPU time away from older ones.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li>Simple and straightforward to implement.</li>
                        <li>Ensures each task is completed based on arrival time, maintaining fairness for batch
                            processing.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Convoy Effect:</strong> Shorter tasks can be delayed by a long-running process that
                            arrived earlier, leading to inefficient CPU utilization.</li>
                        <li><strong>High Waiting Times:</strong> Average waiting time can be high since tasks must wait
                            for all preceding ones to complete, regardless of their execution time.</li>
                    </ul>
                    <p><strong>Use Case:</strong> Typically used in batch systems or for simple job queues where
                        response time isn’t a high priority.</p>
                    <!-- <a href="https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/#1-first-come-first-serve"
                        style="color: red;" target="_blank">
                        Read Documentation
                    </a> -->
                </div>
            </div>

            <!-- SJF -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('sjf')">Shortest Job First (SJF)
                        /
                        Shortest Job Next (SJN)
                    </a>
                    <p>SJF selects the process with the shortest estimated execution time next. The main objective is
                        to...</p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('sjf')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>
                <div class="card" id="sjf-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>Shortest Job First (SJF) / Shortest Job Next (SJN)</h2>
                    <p><strong>Mechanism:</strong> SJF selects the process with the shortest estimated execution time
                        next.
                        The main objective is to minimize the average waiting time.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Non-preemptive:</strong> Once started, the selected job runs until it’s finished.
                            However, in some systems, a <b>Preemptive SJN</b> variant called Shortest Remaining Time
                            First
                            (SRTF) interrupts a running process if a shorter job arrives.</li>
                        <li><strong>Optimal for Waiting Time:</strong> Minimizes average waiting time compared to other
                            algorithms,
                            given that shorter jobs are executed first.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li>Efficiently reduces waiting time by running shorter processes ahead of longer ones.</li>
                        <li>Better suited for time-sensitive jobs and tasks with known execution times.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Requires Knowledge of Execution Time:</strong> SJN relies on knowing the length of
                            each job, which isn’t always possible in real-world scenarios.</li>
                        <li><strong>Starvation of Longer Jobs:</strong> Long-running processes may be continuously
                            postponed
                            if shorter jobs keep arriving, potentially leading to indefinite waiting times for large
                            tasks. </li>
                    </ul>
                    <p><strong>Use Case:</strong> Often used in batch processing systems or situations where task
                        durations
                        can be estimated. It is less commonly used in interactive systems where process times vary
                        significantly.</p>
                </div>
            </div>

            <!-- SRT -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('srtf')">Shortest Remaining Time
                        First (SRTF)
                    </a>
                    <p>SRTF is a preemptive version of Shortest Job Next (SJN). The CPU selects the process with the...
                    </p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('srtf')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>
                <div class="card" id="srtf-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>Shortest Remaining Time First (SRTF)</h2>
                    <p><strong>Mechanism:</strong> SRTF is a preemptive version of Shortest Job Next (SJN). The CPU
                        selects the process with the shortest remaining time to complete.
                        If a new process arrives with a shorter remaining time than the current one, it preempts the
                        current process.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Preemptive:</strong> Processes are interrupted if a new job with a shorter remaining
                            time arrives.</li>
                        <li><strong>Optimized Waiting Time:</strong> Since shorter jobs are prioritized, average waiting
                            time is minimized.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li><strong>Efficient Waiting Times:</strong> Reduces overall waiting time by dynamically
                            selecting the shortest remaining job.</li>
                        <li><strong>Better for Interactive Systems:</strong> More responsive as shorter tasks are
                            completed faster.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Requires Knowledge of Job Length:</strong> Accurate estimation of job lengths is
                            necessary,
                            which may be difficult or impossible in certain situations.</li>
                        <li><strong>Frequent Context Switching:</strong> Preemptions can lead to high context-switching
                            overhead,
                            potentially slowing down the system.</li>
                    </ul>
                    <p><strong>Use Case:</strong> Often suitable for interactive environments where smaller tasks
                        benefit from
                        priority, like time-sharing systems, but may be less effective in systems where task lengths are
                        unpredictable.</p>
                </div>
            </div>

            <!-- Priority -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('priority')">Priority Scheduling
                    </a>
                    <p>Processes are assigned priority levels (usually numerical).
                        The CPU selects the process with the...</p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('priority')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>
                <div class="card" id="priority-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>Priority Scheduling</h2>
                    <p><strong>Mechanism:</strong> Processes are assigned priority levels (usually numerical).
                        The CPU selects the process with the highest priority first, executing it either until it’s
                        done (non-preemptive) or until a higher-priority process arrives (preemptive).</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Can Be Preemptive or Non-preemptive:</strong> In a preemptive version, if a
                            higher-priority process
                            arrives, it interrupts the current process.
                            In a non-preemptive version, the current process continues until it’s completed.</li>
                        <li><strong>Flexibility in Priority Assignment:</strong> Priority levels can be set based on
                            factors like
                            resource needs, user importance, or deadlines.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li><strong>Efficiency for Critical Tasks:</strong> Critical processes can be given priority to
                            ensure timely execution.</li>
                        <li><strong>Customizable:</strong> Can be adjusted to suit system or user needs based on the
                            importance of tasks.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Starvation:</strong> Lower-priority tasks can experience indefinite delays if
                            high-priority tasks keep arriving.</li>
                        <li><strong>Aging Requirement:</strong> To prevent starvation, priority scheduling often
                            requires aging
                            (increasing priority over time for waiting processes) to ensure eventual CPU time.</li>
                    </ul>
                    <p><strong>Use Case:</strong> Useful for systems that handle both critical and routine processes,
                        such as real-time operating systems where certain tasks (e.g., handling hardware interrupts)
                        need immediate CPU access over regular user processes.</p>
                </div>
            </div>

            <!-- RR -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('rr')">Round Robin (RR)
                    </a>
                    <p>Each process is assigned a fixed time quantum or time slice (e.g., 10ms). Processes are placed in
                        a...</p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('rr')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>
                <div class="card" id="rr-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>Round Robin (RR)</h2>
                    <p><strong>Mechanism:</strong> Each process is assigned a fixed time quantum or time slice (e.g.,
                        10ms).
                        Processes are placed in a circular queue, and the CPU switches between them after each time
                        slice,
                        giving each process a share of CPU time in a cyclic order.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Preemptive:</strong> After each time quantum, if a process hasn’t completed, it’s
                            moved to the
                            back of the queue, and the CPU shifts to the next process.</li>
                        <li><strong>Responsive:</strong> Allows processes to get a regular share of CPU time, making it
                            suitable for time-sharing systems.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li>Improves response time for all processes since they regularly get CPU attention within each
                            cycle.</li>
                        <li>Fairly shares CPU time across all processes, preventing any single process from monopolizing
                            the CPU.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Overhead:</strong> Frequent context switches are necessary, which can introduce
                            overhead and reduce overall system efficiency.</li>
                        <li><strong>Time Quantum Selection:</strong> If the time slice is too short, the overhead from
                            context switches will increase;
                            if it’s too long, it behaves similarly to FCFS and reduces responsiveness.</li>
                    </ul>
                    <p><strong>Use Case:</strong> Common in interactive and time-sharing systems, like operating systems
                        for multi-user environments,
                        where each user or application needs responsive CPU time.</p>
                </div>
            </div>

            <!-- Multilevel Queue -->
            <div class="blog-box">
                <div class="blog-text">
                    <a href="javascript:void(0);" class="blog-title" onclick="openCard('mlq')">Multilevel Queue (MLQ)
                    </a>
                    <p>This algorithm divides processes into multiple queues based on priority, type, or required...</p>
                    <a href="javascript:void(0);" id="more" onclick="openCard('mlq')">Read More</a>
                </div>

                <div class="overlay" onclick="closeCard()"></div>
                <div class="card" id="mlq-card">
                    <button class="close-btn" onclick="closeCard()">x</button>
                    <h2>Multilevel Queue (MLQ)</h2>
                    <p><strong>Mechanism:</strong> This algorithm divides processes into multiple queues based on
                        priority,
                        type, or required resources (e.g., system processes, interactive tasks, and batch jobs).
                        Each queue can have its own scheduling algorithm, like Round Robin or FCFS, and processes do not
                        move between queues.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li><strong>Non-preemptive or Preemptive:</strong> Each queue operates independently, and the
                            system can prioritize queues by hierarchy (e.g., system processes always run before batch
                            jobs).</li>
                        <li><strong>Segregated by Type:</strong> Each queue caters to a different type of process, and
                            priority is set at the queue level.</li>
                    </ul>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li><strong>Efficient Task Management:</strong> By grouping similar tasks, the system can handle
                            different process types more efficiently.</li>
                        <li><strong>Flexible and Customizable:</strong> Different scheduling algorithms can be applied
                            to each queue based on process requirements.</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li><strong>Rigid Queue Assignment:</strong> Processes are assigned to specific queues and
                            cannot switch, which may lead to inefficiency if a high-priority task is in a low-priority
                            queue.</li>
                        <li><strong>Risk of Starvation:</strong> Lower-priority queues may experience starvation if
                            high-priority queues remain occupied.</li>
                    </ul>
                    <p><strong>Use Case:</strong> Common in systems with varied types of processes requiring different
                        priorities, such as OS-level scheduling in time-sharing and real-time systems, where system
                        tasks are prioritized over user tasks.</p>
                </div>
            </div>
        </div>
    </section>


    <section class="footer">
        <p>Made With <i class="far fa-heart"></i> by Vaibhav & Diya</p>
        <p><i class="fa fa-copyright"></i> copyright 2024 | All rights reserved</p>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
        integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
        crossorigin="anonymous"></script>

    <script>
        var navLinks = document.getElementById("navLinks");
        function showMenu() {
            navLinks.style.right = "0";
        }

        function hideMenu() {
            navLinks.style.right = "-200px";
        }

        function gotoSimulator() {
            location.href = ("./backend/ganttcharts.html");
        }
    </script>


    <!-- For the animation -->
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>
        AOS.init({
            offset: 200, // offset (in px) from the original trigger point
            duration: 600
        });
    </script>


    <script>
        // Function to open a card based on the algorithm type
        function openCard(algo) {
            document.querySelector('.overlay').style.display = 'block';
            document.getElementById(algo + '-card').style.display = 'block';
        }

        // Function to close all cards
        function closeCard() {
            document.querySelector('.overlay').style.display = 'none';
            document.querySelectorAll('.card').forEach(card => {
                card.style.display = 'none';
            });
        }
    </script>
</body>

</html>